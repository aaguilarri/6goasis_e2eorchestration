# Copyright 2026 Nearby Computing S.L.
import random
import math
import matplotlib.pyplot as plt
import copy  # Add this line to fix the error

random.seed(10)

# Configuration
M = 5  # Number of regions and edge servers
N = 3  # Number of applications
max_cpu_capacities = [16, 20, 12, 18, 14]  # Max CPU cores for each edge server
num_events = 100  # Number of events
cpu_requirements = [2, 4, 6]  # Example CPU requirements for each application
optimal_traffic = [50, 100, 150]  # Example optimal traffic in Mbps for each application
power_dynamic = 0.5  # Example dynamic power consumption per CPU unit in watts
power_static = 10  # Example static power consumption in watts
time_interval = 3600  # Simulation time interval in seconds (1 hour)

# Function to generate random data for each event
def generate_event_data():
    event_data = []
    for _ in range(num_events):
        event = {}
        event['users_per_region'] = [random.randint(10, 50) for _ in range(M)]
        event['apps_per_user'] = [[] for _ in range(M)]
        
        for region in range(M):
            for _ in range(event['users_per_region'][region]):
                app = random.randint(0, N-1)
                event['apps_per_user'][region].append(app)
        
        event_data.append(event)
    return event_data

# Function to calculate traffic and replicas needed with scaling
def calculate_traffic_and_replicas_with_scaling(event_data):
    for event in event_data:
        event['traffic_per_region_per_app'] = [[0 for _ in range(N)] for _ in range(M)]
        event['replicas_per_region_per_app'] = [[0 for _ in range(N)] for _ in range(M)]
        
        for region in range(M):
            for user in range(event['users_per_region'][region]):
                app = event['apps_per_user'][region][user]
                traffic = random.randint(1, 10)  # Example traffic generated by each user in Mbps
                event['traffic_per_region_per_app'][region][app] += traffic
        
        for region in range(M):
            for app in range(N):
                total_traffic = event['traffic_per_region_per_app'][region][app]
                event['replicas_per_region_per_app'][region][app] = math.ceil(total_traffic / optimal_traffic[app])

# Function to check CPU capacity and calculate energy consumption
def check_cpu_capacity_and_energy(event_data, deploy_all_apps):
    energy_consumption = []
    utilization_exceeded_events = []
    
    for event_index, event in enumerate(event_data):
        event['cpu_usage_per_region'] = [0 for _ in range(M)]
        
        for region in range(M):
            if deploy_all_apps:
                # Deploy all applications regardless of user presence (1 replica of each application)
                for app in range(N):
                    replicas = max(1, event['replicas_per_region_per_app'][region][app])
                    event['cpu_usage_per_region'][region] += replicas * cpu_requirements[app]
            else:
                # Deploy applications only if there are users
                for app in set(event['apps_per_user'][region]):
                    replicas = event['replicas_per_region_per_app'][region][app]
                    event['cpu_usage_per_region'][region] += replicas * cpu_requirements[app]
        
        event['cpu_capacity_met'] = [usage <= max_cpu_capacities[region] for region, usage in enumerate(event['cpu_usage_per_region'])]
        
        # Calculate energy consumption
        event_energy = []
        utilization_exceeded = []
        for region in range(M):
            cpu_usage = event['cpu_usage_per_region'][region]
            max_capacity = max_cpu_capacities[region]
            dynamic_energy = cpu_usage * power_dynamic  # In watts

            # Add static energy if any application is deployed
            static_energy = power_static if cpu_usage > 0 else 0
            
            # Energy consumed by dynamic and static power over the time interval
            total_energy = (static_energy + dynamic_energy) * time_interval  # In joules (Watts * Seconds)

            utilization_exceeded.append(cpu_usage > max_capacity)
            event_energy.append(total_energy / 1000)  # Convert to kilojoules (1 kJ = 1000 J)
        
        energy_consumption.append(event_energy)
        utilization_exceeded_events.append(utilization_exceeded)
    
    return energy_consumption, utilization_exceeded_events

# Simulation functions
def run_baseline_simulation(event_data):
    calculate_traffic_and_replicas_with_scaling(event_data)
    return check_cpu_capacity_and_energy(event_data, deploy_all_apps=True)

def run_proposed_simulation(event_data):
    calculate_traffic_and_replicas_with_scaling(event_data)
    return check_cpu_capacity_and_energy(event_data, deploy_all_apps=False)

# Plotting function
def plot_comparison(energy_baseline, energy_proposed, utilization_baseline, utilization_proposed, num_events):
    plt.figure(figsize=(12, 6))
    
    # Plot energy consumption
    plt.subplot(1, 2, 1)
    plt.plot(range(num_events), [sum(e) / M for e in energy_baseline], label='Baseline')
    plt.plot(range(num_events), [sum(e) / M for e in energy_proposed], label='Proposed')
    plt.xlabel('Event')
    plt.ylabel('Energy Consumption (kJ)')  # Updated to Kilojoules (kJ)
    plt.title('Energy Consumption Comparison (in kJ)')
    plt.legend()
    
    # Plot CPU utilization exceeded events as bar chart
    plt.subplot(1, 2, 2)
    baseline_exceeded_counts = [sum(e) for e in utilization_baseline]
    proposed_exceeded_counts = [sum(e) for e in utilization_proposed]
    
    bar_width = 0.35
    index = range(num_events)
    
    plt.bar(index, baseline_exceeded_counts, bar_width, label='Baseline')
    plt.bar([i + bar_width for i in index], proposed_exceeded_counts, bar_width, label='Proposed')
    
    plt.xlabel('Event')
    plt.ylabel('Number of Regions Exceeding CPU Capacity')
    plt.title('CPU Utilization Exceeded Comparison')
    plt.legend()
    
    plt.show()

if __name__ == "__main__":
    # Scenarios for M (regions) and N (applications)
    num_regions_scenarios = [2, 5, 10, 20, 50]  # Number of regions
    num_apps_scenarios = [1, 5, 10, 20, 40, 50]  # Number of applications

    # 2D arrays to store average energy consumption
    energy_results_baseline = []
    energy_results_proposed = []

    for num_regions in num_regions_scenarios:
        # Initialize row for this M
        baseline_row = []
        proposed_row = []

        for num_apps in num_apps_scenarios:
            # Update number of regions and applications
            M = num_regions
            N = num_apps

            max_cpu_capacities = [random.randint(10, 20) for _ in range(M)]  # Random CPU capacities
            cpu_requirements = [random.randint(1, 8) for _ in range(N)]  # Random CPU requirements
            optimal_traffic = [random.randint(50, 200) for _ in range(N)]  # Random optimal traffic

            # Generate event data for the current combination of M and N
            shared_event_data_baseline = generate_event_data()
            shared_event_data_proposed = copy.deepcopy(shared_event_data_baseline)

            # Run simulations
            energy_baseline, _ = run_baseline_simulation(shared_event_data_baseline)
            energy_proposed, _ = run_proposed_simulation(shared_event_data_proposed)

            # Collect average energy consumption
            avg_energy_baseline = sum([sum(e) / M for e in energy_baseline]) / num_events
            avg_energy_proposed = sum([sum(e) / M for e in energy_proposed]) / num_events

            baseline_row.append(avg_energy_baseline)
            proposed_row.append(avg_energy_proposed)

        # Append results for this M
        energy_results_baseline.append(baseline_row)
        energy_results_proposed.append(proposed_row)

    # Visualization as Heatmap
    import seaborn as sns
    import matplotlib.pyplot as plt

    # Determine the global min and max energy values across both datasets
    global_min = min(min(row) for row in energy_results_baseline + energy_results_proposed)
    global_max = max(max(row) for row in energy_results_baseline + energy_results_proposed)

    # Calculate percentage reduction
    energy_reduction_percentage = [
        [
            (baseline - proposed) / baseline * 100 if baseline > 0 else 0
            for baseline, proposed in zip(baseline_row, proposed_row)
        ]
        for baseline_row, proposed_row in zip(energy_results_baseline, energy_results_proposed)
    ]

    # Add this code block here to log the results
    import json

    # Prepare data for logging
    log_data = {
        "num_regions_scenarios": num_regions_scenarios,
        "num_apps_scenarios": num_apps_scenarios,
        "energy_reduction_percentage": energy_reduction_percentage
    }

    # Save to a JSON file
    with open("energy_reduction_log.json", "w") as json_file:
        json.dump(log_data, json_file, indent=4)

    print("Energy reduction percentages have been logged to 'energy_reduction_log.json'.")

    # Adjust figure size to include the new heatmap
    plt.figure(figsize=(10, 18))

    # Heatmap for Baseline Energy Consumption
    plt.subplot(3, 1, 1)  # Three rows, one column, first plot
    sns.heatmap(
        energy_results_baseline,
        annot=True,
        fmt=".0f",
        xticklabels=num_apps_scenarios,
        yticklabels=num_regions_scenarios,
        cmap="YlOrRd",
        vmin=global_min,
        vmax=global_max,
        cbar_kws={'label': 'Energy (kJ)'}
    )
    plt.title("No Network-aware Energy Consumption (in kJ)", fontsize=16)
    plt.xlabel("Number of Applications (N)", fontsize=14)
    plt.ylabel("Number of Regions (M)", fontsize=14)

    # Heatmap for Proposed Energy Consumption
    plt.subplot(3, 1, 2)  # Three rows, one column, second plot
    sns.heatmap(
        energy_results_proposed,
        annot=True,
        fmt=".0f",
        xticklabels=num_apps_scenarios,
        yticklabels=num_regions_scenarios,
        cmap="YlOrRd",
        vmin=global_min,
        vmax=global_max,
        cbar_kws={'label': 'Energy (kJ)'}
    )
    plt.title("Network-aware Energy Consumption (in kJ)", fontsize=16)
    plt.xlabel("Number of Applications (N)", fontsize=14)
    plt.ylabel("Number of Regions (M)", fontsize=14)

    # Heatmap for Energy Reduction Percentage
    plt.subplot(3, 1, 3)  # Three rows, one column, third plot
    sns.heatmap(
        energy_reduction_percentage,
        annot=True,
        fmt=".1f",
        xticklabels=num_apps_scenarios,
        yticklabels=num_regions_scenarios,
        cmap="Greens",  # Use a distinct color map
        cbar_kws={'label': 'Reduction (%)'}
    )
    plt.title("Energy Reduction Percentage", fontsize=16)
    plt.xlabel("Number of Applications (N)", fontsize=14)
    plt.ylabel("Number of Regions (M)", fontsize=14)

    # Adjust layout and spacing
    plt.tight_layout()
    plt.subplots_adjust(hspace=0.3)  # Increase vertical spacing between subplots

    # Save the figure as a high-resolution PDF
    plt.savefig("energy_reduction_comparison.pdf", dpi=300)

    # Show the plots
    plt.show()